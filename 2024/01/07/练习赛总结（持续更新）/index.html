
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>练习赛总结（持续更新） - Acoipp 的个人博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="OI/ACM 相关笔记,2023-08-17 练习赛总结A 题线段树优化 dp 板子题，10 min 写完。
B 题哈夫曼编码，李煜东书上例题，20 min 写完。
C 题一个不好评价的 cdq 分治，始终卡在四维偏序，有,"> 
    <meta name="author" content="Acoipp"> 
    <link rel="alternative" href="atom.xml" title="Acoipp 的个人博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="练习赛总结（持续更新） - Acoipp 的个人博客"/>
    <meta name="twitter:description" content="OI/ACM 相关笔记,2023-08-17 练习赛总结A 题线段树优化 dp 板子题，10 min 写完。
B 题哈夫曼编码，李煜东书上例题，20 min 写完。
C 题一个不好评价的 cdq 分治，始终卡在四维偏序，有,"/>
    
    
    
    
    <meta property="og:site_name" content="Acoipp 的个人博客"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="练习赛总结（持续更新） - Acoipp 的个人博客"/>
    <meta property="og:description" content="OI/ACM 相关笔记,2023-08-17 练习赛总结A 题线段树优化 dp 板子题，10 min 写完。
B 题哈夫曼编码，李煜东书上例题，20 min 写完。
C 题一个不好评价的 cdq 分治，始终卡在四维偏序，有,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Acoipp 的个人博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">练习赛总结（持续更新）</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">练习赛总结（持续更新）</h1>
        <div class="stuff">
            <span>一月 07, 2024</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%B9%B4%E6%80%BB%E7%BB%93/" rel="tag">年总结</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="2023-08-17-练习赛总结"><a href="#2023-08-17-练习赛总结" class="headerlink" title="2023-08-17 练习赛总结"></a>2023-08-17 练习赛总结</h1><p>A 题线段树优化 dp 板子题，10 min 写完。</p>
<p>B 题哈夫曼编码，李煜东书上例题，20 min 写完。</p>
<p>C 题一个不好评价的 cdq 分治，始终卡在四维偏序，有一维可以差分都没想到。。。</p>
<p>但是有同学四维偏序 95 分，我却只有 35。。。</p>
<p>反映出来的情况有：</p>
<ul>
<li>对于以前的知识点记忆还算牢固。</li>
<li>对于新的知识点运用不够熟练。</li>
<li>容易把一个很简单的题复杂化导致过不了。</li>
<li>代码常数太大得优化。</li>
</ul>
<p>C 题耗费太多时间，但是还好没有耽误 A、B 题的得分。</p>
<h1 id="2023-08-19-练习赛总结"><a href="#2023-08-19-练习赛总结" class="headerlink" title="2023-08-19 练习赛总结"></a>2023-08-19 练习赛总结</h1><p>A 题一眼根号分治，然后优化一下就过了。</p>
<p>B 题耗费时间最多，写了个 4000b+ 的玄学做法，还是按 $\bmod \ 3$ 做的，想过搜索，没仔细展开，然后没有想到可以分段，段与段之间再满足条件就可以了。</p>
<p>甚至还有几个猜想，但是知识面有点窄，没想到。</p>
<p>C 题一开始不会做，搞完 B 题之后立马就有了想法，然后回忆了吉司机线段树就通过了几个样例。</p>
<p>D 题最后没时间了，暴力、链、树都没时间写，主要耗费了 2h 在 B 题上面。</p>
<p>总之呢，发挥比较失常，对于构造题还得再练一练，其实反映的是思维的灵敏上的问题。</p>
<h1 id="2023-08-24-ACM组队赛总结"><a href="#2023-08-24-ACM组队赛总结" class="headerlink" title="2023-08-24 ACM组队赛总结"></a>2023-08-24 ACM组队赛总结</h1><p>配合得非常好，我们四个人基本上把能做的都做了，但是遗憾在于作死把自己给弄了。</p>
<p>B 题其实我们列出来了方程，但是没有想到可以用记忆化搜索优化它，这说明了对于 dp 方程的不够熟练。</p>
<p>这种类型的 dp，可以去除无用的状态和转移可以节省很多时间。</p>
<p>F 题我也做过类似的题，但是因为卡在了某些东西可以取或者不取，没有想到加一个维度表示它，也算是没能运用得好吧。</p>
<p>综上：dp 题较多，较考验 dp 得套路和类型，但是运用才是最重要的，这些题其实类型都见过但是没能运用的好，这是以后要努力的点。</p>
<h1 id="2023-08-26-练习赛总结"><a href="#2023-08-26-练习赛总结" class="headerlink" title="2023-08-26 练习赛总结"></a>2023-08-26 练习赛总结</h1><p>A 题浪费太多时间了，思路先是三维的，然后发现第一维没用直接去掉，最后前缀和优化两维就可以了，但是做了两个小时。。。</p>
<p>B 题是一上来数位 DP 就切掉，没什么好说的。</p>
<p>C，D 题完全没时间做了，C 题的 15 分还忘记删去调试语句。。。</p>
<p>D 题骗了 20 分的部分分。</p>
<p>实际上如果顺着我的贪心思路走下去的话应该能够拿到 70 分。</p>
<p>综上：就是 A 题时间分配不均匀导致后面一些能够做出来的题只拿到了很少的分，所以要均匀分配时间。</p>
<p>A 题的题解做法也很妙，这里就不展开讲了。。。</p>
<h1 id="2023-09-02-练习赛总结"><a href="#2023-09-02-练习赛总结" class="headerlink" title="2023-09-02 练习赛总结"></a>2023-09-02 练习赛总结</h1><p>A 题直接切掉，信心满满以为能过，实际上被卡时间了，正解是 $\log$ 的解法。。。（我们一定不要高估教师机的速度）</p>
<p>B，C 题是比较简单的题目，C 题正解是矩阵乘法，但是我用的是分块，因为开了 4s，所以能过。</p>
<p>D 题手玩了一下，浪费了很多时间，发现对于每个点连接与它最近的点就可以了，但是大样例没过，然后改成最近的 $7$ 个点就通过了。</p>
<p>然后 liyixi_i 大佬证了只需要 $2$ 个点，PPT 也提供了一种巧妙的解法。</p>
<p>综上：D 题这种关于连通性的题目一定要相互转化，比如 $A,B$ 连通，$B,C$ 连通，我们可以近似地看做 $A,C$ 连通且有边（当然会有一些前提条件，要看题目规定）</p>
<p>Fiyuls AK 了，让我们为 AK 之王的诞生献上礼炮！</p>
<h1 id="2023-09-10-练习赛总结"><a href="#2023-09-10-练习赛总结" class="headerlink" title="2023-09-10 练习赛总结"></a>2023-09-10 练习赛总结</h1><p>A 题我不好评价，这么一道裸的 kruskal 重构树的题，愣是想了 1h 才弄出来，之前一直在想边权从大到小，后面发现从小到大才能过。</p>
<p>这真是印证了小周老师（数学）的一句话：你们聪明是聪明，但就是不懂得“见势不妙，赶紧开溜”。</p>
<p>B 题之后就一直在搞，最后能搞出来 50 分是我意想不到的，C 题抽空打了暴力，但是赛后发现我的反悔贪心是对的，只不过因为 B 题的原因就没有写贪心的做法，真是肠子都悔青了。（<del>虽然也有决策单调性的做法</del>）</p>
<p>D 题碍于题目原因，根本就读不懂样例，10 分都没拿到。</p>
<p>总结呢，就是要尝试更换方法，不能死磕某一个东西，然后要慢慢找到做题的节奏才能拿到更多的分。对于构造题还需要加强，类似于 B 题这种构造性思维是做题必备的。</p>
<h1 id="2023-09-13-练习赛总结"><a href="#2023-09-13-练习赛总结" class="headerlink" title="2023-09-13 练习赛总结"></a>2023-09-13 练习赛总结</h1><p>A、C、D 题几乎都是一眼秒，但是 D 题时间复杂度算错了浪费了一些时间。</p>
<p>然后 B 题一直在想为什么我的做法不对，后面仔细阅读题意之后发现了问题所在，并不一定要全部连通，我们只需要连通块内的数的和为 $0$ 就可以了，然后也是做完。</p>
<p>顺利 AK 了，然后大概就是需要加强一下理解题意的能力，做题的时候要严谨，特别是时间空间复杂度要算对，最好是造一组数据来测一下。</p>
<p>打的不错，下次继续努力。</p>
<h1 id="2023-09-19-练习赛总结"><a href="#2023-09-19-练习赛总结" class="headerlink" title="2023-09-19 练习赛总结"></a>2023-09-19 练习赛总结</h1><p>A、B、D 题基本上没有什么大问题，只不过 D 题最下面那行文字确实坑了我一会时间，也许补回来就能把 C 题 A 掉了。</p>
<p>C 题一看上去就知道是树重构，然后找到重心之后用哈希就可以了，但是两个重心的情况判错了。</p>
<p>第一发提交还被卡了哈希，后面 random_shuffle 一下才得到了 63 分。</p>
<p>总之就是需要锻炼 1A 率，然后不要在简单的题目上耗费太多的时间，题目需要认真地读完才行，这次比赛表现一般吧。</p>
<h1 id="2023-09-23-练习赛总结"><a href="#2023-09-23-练习赛总结" class="headerlink" title="2023-09-23 练习赛总结"></a>2023-09-23 练习赛总结</h1><p>A、B、C、D 题基本上都有解法，主要就是 D 题的想法不太熟练，复制了一份之后又没有开大数组，挂了 30 分。直接奶茶–&gt;巧克力。</p>
<p>说明了对于每一道题我们都要细致地弄懂，不要不懂装懂，不懂的题一定要及时弄懂，否则后患无穷。（今天的 D 题就是之前的原题，如果记得之前的原题的话可能就不会出现数组开小的情况）</p>
<p>A、B、C 做得比较快，B 题是乱搞，正解简称人类智慧，值得学习。</p>
<p>附一句：liyixi AK 了，Orz。</p>
<h1 id="2023-09-27-练习赛总结"><a href="#2023-09-27-练习赛总结" class="headerlink" title="2023-09-27 练习赛总结"></a>2023-09-27 练习赛总结</h1><p>A、B、C、D 题过得比较顺利，但是 E 题消耗了太多时间了。</p>
<p>先开始写的是递归，然后发现被卡常了（本地不开 O2 跑了 0.9s，OJ 上开 O2 跑了 2.3s）。</p>
<p>后面改成循环的解法，在 OJ 上测了几遍就能够跑过。</p>
<p>结果 <code>1e18</code> 开成 <code>1e16</code>，开小了。。。</p>
<p>然后 $3$ 次全部用完了，就没了。。。。。。。。。。。。。</p>
<p>原因是中间有一次调试代码不小心交到比赛界面上了，浪费了一次提交，打乱了我的节奏。。。。。。。。。。。。。。。。。。。。。（真无语啊啊啊啊啊）</p>
<p>以后做题一定要慢下来，慢下来！！！</p>
<p>做题快速但又不要焦躁，以为前 $4$ 题过了就稳了，没想到在第 $5$ 题翻车了。</p>
<p>一定要慢慢来，慢慢来！！！</p>
<h1 id="2023-10-01-练习赛总结"><a href="#2023-10-01-练习赛总结" class="headerlink" title="2023-10-01 练习赛总结"></a>2023-10-01 练习赛总结</h1><p>无</p>
<h1 id="2023-10-03-练习赛总结"><a href="#2023-10-03-练习赛总结" class="headerlink" title="2023-10-03 练习赛总结"></a>2023-10-03 练习赛总结</h1><p>打得很烂，A 题没有判断某种特殊情况，少了 60 分。</p>
<p>D 题画蛇添足，明明排一次序就够了，多排了几次，不知道为什么会 TLE？</p>
<p>然后 WA 也不知道为什么，按理来说答案只会变大，不会变小吧，然后就是数组那些都清空了的。</p>
<p>总之：</p>
<ul>
<li>问题得考虑周全。</li>
<li>尽量不要画蛇添足，除非自己的解法存在事实性错误。</li>
<li>一定要温故而知新，这样才能取得进步！</li>
</ul>
<p>$\color{white}{\texttt{加油！}}$</p>
<h1 id="2023-10-04-练习赛总结"><a href="#2023-10-04-练习赛总结" class="headerlink" title="2023-10-04 练习赛总结"></a>2023-10-04 练习赛总结</h1><p>又一次打得很烂，但是该拿的分都拿到了。</p>
<p>B 题搞不懂贪心，听了讲解之后突然发现很像 lyd 小蓝书上的一道贪心上树的例题。</p>
<p>我推出来了如果是一个序列问题的话就要保证 $b_x \times a_y &gt; b_y \times a_x$，然后一上树就会对拍出错。</p>
<p>结果最后发现要用并查集维护连通块，是连通块之间排序，并不是子树&#x2F;单个点内排序，比较巧妙。（合并的时候合并到父亲就可以了）</p>
<p>C 题也是一道神仙题目，有向图可以划分为 A、B 两个集合，分别处理出来最长路，然后从 $O(N^2)$ 个状态去除无用的（只保留 $\operatorname{value}(i,j)$），就可以很简单地用线段树维护了。</p>
<p>然后为了确保任意时刻都是两个连通块在处理，还要按照拓扑序依次添加节点。</p>
<p>D 题没开，后面讲了发现两维状态分开考虑会很好，于是就变成了经典 2 选 1 求最大交集的问题。</p>
<p>我们就可以用随机赋值来解决了，具体的见 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/674469/xiao-ji-qiao-note-9-post">小技巧</a></p>
<p>总之：</p>
<ul>
<li>B 题的教训：题目减少了，小蓝书上的例题没有仔细地去思考。</li>
<li>C 题：有向图可以考虑去除无用状态，然后按拓扑序增加&#x2F;删除节点。</li>
<li>D 题：两维状态很麻烦，我们可以分开考虑。</li>
</ul>
<p>需要多练题，扩充知识容量，然后一定要跳出圈来重新想一下，C 题就陷在之前的一个想法里面了。</p>
<p>B 题的贪心说明这种类型的题目还需要多练，我对于贪心没有太多感觉。</p>
<p>$\color{white}{\texttt{加油鸭！}}$</p>
<h1 id="2023-10-07-比赛总结"><a href="#2023-10-07-比赛总结" class="headerlink" title="2023-10-07 比赛总结"></a>2023-10-07 比赛总结</h1><p>A 题搞了 2 个小时是我没有想到的。</p>
<p>这种改算法的题要求对算法的理解比较重要，说明基础还是薄弱了一些。</p>
<p>B 题没做出来没有想到那里去，部分分也懒得写了。</p>
<p>C 题本来可以得 70 分的，但是一通乱搞过后就只有 50 分了，然后思路也挺神仙，只考虑到了 $k&#x3D;0$ 的情况如何处理，还有数据范围提示我们要面向数据编程。</p>
<p>D 题得了 60 分，没有考虑到容斥就很烦。</p>
<p>综上呢，这场比赛神仙题居多，打这种比赛确实有助于提升比赛能力，同时也暴露出了不足，就是套路题做多了，这种思维题就会出问题。</p>
<p>提高思维能力最重要。</p>
<h1 id="2023-10-07-比赛总结-1"><a href="#2023-10-07-比赛总结-1" class="headerlink" title="2023-10-07 比赛总结"></a>2023-10-07 比赛总结</h1><p>A 题居然只得了 76 分是我没有想到的。</p>
<p>A 题有一种情况多考虑了，导致了这个分数的产生。</p>
<p>B 题一般吧，没有消耗太多时间，C 题没有考虑到可以消状态。</p>
<p>C 题挺神仙的。</p>
<p>所以需要多练题，特别是思维性质很强的题目才可以。</p>
<h1 id="2023-10-08-比赛总结"><a href="#2023-10-08-比赛总结" class="headerlink" title="2023-10-08 比赛总结"></a>2023-10-08 比赛总结</h1><p>A 题爆炸了，现在都不知道什么原因。</p>
<p>B 题也炸了，预计 80 分的，然后公式推出来了，但是多化简了一步就无法做了。</p>
<p>C 题性质没找到，但是该拿的分都拿到了。</p>
<p>D 题有一个 Subtask 也没拿到，好像是忘记写了（</p>
<p>这场考的不好，下次继续加油，一定要稳定发挥才行。</p>
<h1 id="2023-10-11-比赛总结"><a href="#2023-10-11-比赛总结" class="headerlink" title="2023-10-11 比赛总结"></a>2023-10-11 比赛总结</h1><p>A、B 题差点全部挂掉，但是还好比赛结束的时候留了一手跑了一下发现了一些错误。</p>
<p>做题速度降了下来，发现明显的一 A 趋势。</p>
<p>C 题确实思考了一会，基本上想好了每一个细节再去写代码就没什么大问题。</p>
<p>D 题脑抽，没有想到可以线段树维护 gcd，确实前面的结论都推导完了，但是骗了 75 分（</p>
<p>这场比赛发挥不错，下次继续努力。</p>
<p>稳是最重要的！</p>
<h1 id="2023-10-12-比赛总结"><a href="#2023-10-12-比赛总结" class="headerlink" title="2023-10-12 比赛总结"></a>2023-10-12 比赛总结</h1><p>挂分 $0+40+67+70 \sim 80$。</p>
<p>A 题没挂分，因为想得很透彻，而且实现比较简单，做的时间跟预料情况差不多。</p>
<p>B 题【小粉兔】的，匈牙利算法模板打错了，还有听说同学们匈牙利算法被卡了，但是我跑得飞快，而且本机上 0.2s 就跑过去了。</p>
<p>C 题【小粉兔】的，数组开小了，因为 $k$ 和 $n$，不同阶，后面忘记改回来了，真的是服了。</p>
<p>还有就是 B 题耗费了很多时间，原因是考虑到了奇数和偶数可以分开，但是一直没考虑到二分图。。。</p>
<p>D 题分讨少了一些东西，又挂了。。。</p>
<p>这场是挂分场啊，B 题浪费的时间太多了，主要是如果一个图可以划分成两个集合，集合内没有边，我们就可以用二分图求解最大独立集问题，虽然这个问题在普通图上是 NPC 问题。。。</p>
<h1 id="2023-10-15-比赛总结"><a href="#2023-10-15-比赛总结" class="headerlink" title="2023-10-15 比赛总结"></a>2023-10-15 比赛总结</h1><p>准确来说没有挂分。</p>
<p>A、B 题 100 分差不多，B 题中途想了一下 $O(n^{\frac{3}{4}})$ 的做法，后来感觉会被卡，就用成了 $n\le 10^7$ 时 $O(1)$ 查询的线性筛做法。</p>
<p>A 题之前做过类似的自然数拆分，注意到层数不会超过 $\sqrt{N}$ 层，那么就可以愉快地背包 DP 了。</p>
<p>C 题有一个很直接的 $O(n \sqrt{n})$ 的做法，敲完之后时间已经不多了，突然发现常数大的离谱，要执行 $2 \sim 3$ 次，然后时间限制只有 2s，想来也没有办法挽救了。</p>
<p>后来发现我们可以像虚树一样保留关键节点，那样的话对于每条链缩一下点就很轻松解决了，时间复杂度是单 $\log$，可惜的是考场上始终坚信分块的根号时间复杂度能够卡过去，而没有考虑更巧妙实现也更简单的单 $\log$ 做法。</p>
<p>A 题也浪费了很多时间，主要是模型转化慢了些，对之前掌握的知识不太熟练，公式推得不是很顺手。</p>
<p>D 题很简单的贪心都没有想到，完全是没有思路，事实上我们可以优化一些看似不对的解法使得其通过。这种题目主要是锻炼创造性思维，想不到那里去就永远做不出来了。</p>
<p>总而言之 A、B、D 题代码都很短而且很具思维能力，值得一写。C 题主要锻炼代码力和对于时间复杂度的把握，当时因为对时间复杂度的过于自信，导致很多人都被分块卡了时间。</p>
<p>下次先想好时间复杂度<strong>特别是常数</strong>再写，就会稳定许多。</p>
<h1 id="2023-10-16-比赛总结"><a href="#2023-10-16-比赛总结" class="headerlink" title="2023-10-16 比赛总结"></a>2023-10-16 比赛总结</h1><p>A 题调了很久，原因是变量名相同的混用了。</p>
<p>以后声明变量的时候一定要有较高的区分度，这样有助于我们调试代码。</p>
<p>B 题不是很麻烦，构建笛卡尔树的时候记住“栈中维护一条向右边的链”就很好做了。</p>
<p>C 题比较有智慧，首先我们可以发现只有两边的有出口的机器人会对答案造成贡献，然后写一下公式再转化到图上就是一个二维偏序问题了。</p>
<p>那么我们获得了一个小技巧，有两维状态的元素可以考虑放到平面直角坐标系上面去观察规律。</p>
<p>D 题更是人类智慧了，可以放到平面直角坐标系上面转化为最短路问题，然后用线段树跑一个 Dijkstra 就可以了，因为这道题边权在点上，所以很好实现。</p>
<p>这次比赛让我收获了许多，特别是这个 Trick，太妙了！</p>
<h1 id="2023-10-17-比赛总结"><a href="#2023-10-17-比赛总结" class="headerlink" title="2023-10-17 比赛总结"></a>2023-10-17 比赛总结</h1><p>去 CQYZ 比赛，感觉这场比赛比春测还春测。——一个不愿意透露姓名的大佬。</p>
<p>低级失误很多，我也总结了一下，为以后避雷：</p>
<ol>
<li>Linux下 #include&lt;windows.h&gt;   </li>
<li>没开 long long   </li>
<li>函数没有返回值   </li>
<li>Runtime Error 全都是我害的。。。还要把 windows.h 纹我脸上。。。</li>
<li>上界开小  </li>
<li>在F盘《建子文件夹》</li>
<li>空间算错</li>
</ol>
<p>把我看乐了。</p>
<p>总结一下，打的不错，节奏比较稳定，然后剩下了 1 个小时来对拍，对拍的过程比较顺利，后面发现了一个小的边界错误，改了就能过拍了。</p>
<p>最后对拍完剩了 10 分钟，看了一下 J 组的题目，感觉比 J 组整体难度要难一些，但是比较模板（D 题）。</p>
<p>希望以后能够保持这个节奏，教练说得对，慢下来做题，争取不要挂分，最大的对手是自己的心态。</p>
<p>$\color{white}{\text{周六 CSP-J&#x2F;S RP++，一切顺利！}}$</p>
<h1 id="2023-10-19-比赛总结"><a href="#2023-10-19-比赛总结" class="headerlink" title="2023-10-19 比赛总结"></a>2023-10-19 比赛总结</h1><p>准确的说前 1 个小时拿到了所有分数。</p>
<p>C 题涉及到立体几何就有点做不起了，有人用勾股定理和海伦公式做出来了，只能说明我推式子的能力不太行。</p>
<p>于是便跳过 C 题去做 D 题，D 题其实很模板，当时教练讲的内容差不多忘完了，所以就想了一个差不多的解法，一直调到了比赛结束，大样例发下来之后发现做法假了。</p>
<p>也没时间打暴力，所以愉快地 200 了。</p>
<p>我们需要多去收集一些套路，这些套路有时会很实用，然后对于我来说，需要提高自己的推公式的能力，然后运用各种定理&#x2F;猜想的创造力才行。</p>
<p>4.5 h，时间分配还好，主要是没有想到 3、4 题浪费了这么多时间。</p>
<p>最后一点就是我一直在纠结做 3，还是做 4，中途思维跳来跳去的，打断了连续性，故时间不太够用，消耗了最后的打暴力时间。</p>
<p>打得一般，下次继续努力。争取在明天 CSP-J&#x2F;S 发挥最佳实力！</p>
<p>$\color{white}{\text{Tomorrow CSP-J&#x2F;S RP++. All the BEST !}}$</p>
<h1 id="2023-10-28-比赛总结"><a href="#2023-10-28-比赛总结" class="headerlink" title="2023-10-28 比赛总结"></a>2023-10-28 比赛总结</h1><p>D 题有点不正常，调了很久，后面发现是 dp 式子列错了，但是还是小的错误不算大。</p>
<p>B 题时间复杂度算错了，是 $O(7^5 n^3)$ 而不是 $O(7n^3)$，然后方便起见弄了一个 Floyd，直接 TLE 掉。</p>
<p>A、C 题其实比较好想，A 题用可撤销背包代替或运算是比较巧妙的。</p>
<p>C 题的贪心看过 lyd 的蓝书之后就很简单了，就是形如 $lllllxrrrrrr$ 这种方式，暴力合并果子就可以了。</p>
<p>总分比较理想，发挥较稳定。</p>
<p>每道题目的用时：$30 \sim 40\text{ min}$（较慢），$30 \sim 40\text{ min}$（较快，但是 TLE），$60 \text{ min}$（正常），$120 \pm 30$（较慢），思维题目的想的时间需要减少。</p>
<p>这场比赛调代码不算难。</p>
<h1 id="2023-10-30-比赛总结"><a href="#2023-10-30-比赛总结" class="headerlink" title="2023-10-30 比赛总结"></a>2023-10-30 比赛总结</h1><p>大模拟场，我个人认为做得比较快，但是 E 题 OJ <code>ios::sync_with_stdio(false);</code> 挂了，我也不知道为什么，以后稍微注意一下。</p>
<p>做了 A+B+C+E 四道题，B 题前 9 次想着使用奇技淫巧卡过去，但是可能有点拼人品，最后一次又加了几个剪枝就过了。</p>
<p>大模拟还是码力有点弱，写了很久才过。</p>
<p>用时均是 $30 \text{ min}$ 左右，B 题卡了一会常，浪费了十几分钟，然后 E 题因为 <code>cin</code> 的原因没有做得出来，C 题则是因为调试了一会没有快速切掉，还因为数组开小 RE 了一次。</p>
<p>做大模拟需要细节的把握，但是 E 题的细节很多能够在 2 次内 AC 也是比较好得一个表现，静下心来有助于解题。</p>
<h1 id="2023-10-31-比赛总结"><a href="#2023-10-31-比赛总结" class="headerlink" title="2023-10-31 比赛总结"></a>2023-10-31 比赛总结</h1><p>预期 A+B+C+（D 的一部分），但是 A 题挂了，B 题挂了，D 题挂了。</p>
<p>A 题耗时 $1 \text{ h}$，然后大样例过了，但是没有对拍导致后面挂掉，中间在改一个小错误的时候没有修改另外一个与之相关联的判断条件就挂了。</p>
<p>甚至因为没有对拍，数组开小了也不知道，真的（反复鞭尸）。</p>
<p>B 题耗时 $30 \sim 40 \text{ min}$，然后也挂了，原因还是没有对拍。。。</p>
<p>《论对拍的重要性》</p>
<p>如果对拍就能发现一种特殊情况，然后调整一小部分代码就可以 AC。。。</p>
<p>然而当时着急去做 C 题（C 题太诈骗了，我同时开了 B 和 C，导致被 C 题卡了心态），原以为 C 题过不去，想了很久 $O(nk)$ 做法，后面打了一个带 $\log$ 的暴力就过了。。。</p>
<p>C 题想了将近 $30 \text{ min}$，最后什么也没搞出来打了一个暴力还过了，事实上 C 题不用“超纲知识”的话是一道错题。</p>
<p>D 题我不好评价，这场比赛 C 题心态崩了之后就一直不顺利，D 题我以为是代码写错了一直调试，剩了 $30 \text{ min}$ 都用来调试（如果用来对拍至少能 A 掉 A、B 题），因为一直以为代码有问题，所以没有打暴力验证，在最后 $5 \text{ min}$ 打了一个暴力，发现暴力输出和我的输出在样例 2 一样（与 std 不一样），在样例 3 一样（暴力与 std 一样），我就一直认为暴力也错了，但是最后 5 分钟能干什么呢？什么也干不了。。。</p>
<p>最后光荣保龄。</p>
<p>我以后打比赛争取开一道题就只想这一道题的内容，不去思考其他题，这样子来说可能会好一些。</p>
<h1 id="2023-11-02-比赛总结"><a href="#2023-11-02-比赛总结" class="headerlink" title="2023-11-02 比赛总结"></a>2023-11-02 比赛总结</h1><p>打炸了。</p>
<p>A 题 30 min 解决，但是最后少了 10 分（在 Linux 上），Windows 上顺利 AC，不知道是怎么回事，前面发挥稳定。</p>
<p>后面 B 题就开始想容斥还有计数，但是后面发现完全容斥不了，总感觉是容斥的方法不对，一直在推容斥的式子，直到考试最后 10 min 才发现把问题转化到数轴上，或者打个 dfs 找找规律都能发现显然的性质。</p>
<p>C 题一眼要么二分图匹配但是有奇环，所以应该是 SG 函数，不会，果断放弃，然后随便交了一份代码，1 分没得。（题目看错了，只能从上往下走，不能走回去，但是发现这点也不重要但能看出读题不细的缺点）</p>
<p>D 题首先想了可并堆，但是发现不对（打了代码才发现，浪费了很多时间）。然后想到线段树优化 DP，因为有前缀 min，想维护差分（受之前做过的题的影响），后面一直调代码，最后发现理论有问题，但是大思路是对的。</p>
<p>最后节奏彻底乱了，B、D 都没能有一道 AC，然后跳过来跳过去，保龄了。</p>
<p>这场比赛我们可以从中获取一些经验：</p>
<blockquote>
<p>想好了，证明了，再写代码。</p>
</blockquote>
<blockquote>
<p>一定要仔细读题，不要以为题目是“自己以为的”那样。</p>
</blockquote>
<blockquote>
<p>如果一个方向不好突破，必须得尝试换一个方向。</p>
</blockquote>
<blockquote>
<p>考试的时候不要被敲键盘的声音所干扰，相信别人打的是暴力。</p>
</blockquote>
<p>警钟长鸣</p>
<h1 id="2023-11-04-比赛总结"><a href="#2023-11-04-比赛总结" class="headerlink" title="2023-11-04 比赛总结"></a>2023-11-04 比赛总结</h1><p>打得一般，原因在于 A 题没有仔细去思考而口胡了一个结论为 $2^{\max(n-2,0)}$，然后认为是对的就没改了。</p>
<p>但是确实没有建立出来模型不好手算故导致了这个结果，花费了大概 $10\text{ min}$，得分 $0$，类似于这样的数学推导需要加强。</p>
<p>然后是 D 题，$10\text{ min}$ 码完了，当时被坑的地方还记得比较清楚，就是重点的情况和“大赦天下”，判断一下就可以了，得分 $100$。</p>
<p>接下来是 B 题，花费了大概 $2 \text{ h}$，感觉性质基本上推到位了，最后三个单调队列维护最大值、最小值、和 dp 数组就可以了。</p>
<p>后面也是圆满对拍过 B 题，但是还是出了一点锅，我当时对于 $k&#x3D;1$ 的数据感觉代码会出问题，于是加了特判，但是题目提供的快写需要 <code>fwrite</code> 结尾，但是这个 <code>if</code> 里面直接 <code>return 0;</code> 了，然后挂了 $14$ 分。</p>
<p>下次对拍程序还是要考虑到各种边界情况，但是这次是<strong>觉得</strong> $k&#x3D;1$ 稳过就没有造 $k&#x3D;1$ 的数据，反倒是这里出了问题，一定要争取万无一失。</p>
<p>C 题一直在想转移，因为矩阵是 $O(N^3)$ 的，根本过不了，但是后面看了题解发现我们开始的方法是对的，只不过是要发现题目的一些性质。</p>
<p>大概就是把 $dp_{i,j}&#x3D;k$，优化为 $dp_{i}&#x3D;j(k \text{最小的情况下})$，然后我们发现剩下的比这个东西优的情况只有 $k+1$，然后线段树暴力合并就可以了。</p>
<p>题目真的很好，A、C 特别有思维性，A 题注重于构造模型，C 题注重于找到性质，只要我们把这两个点 get 到之后就能够掌握一定的解难题的方法了。</p>
<h1 id="2023-11-07-比赛总结"><a href="#2023-11-07-比赛总结" class="headerlink" title="2023-11-07 比赛总结"></a>2023-11-07 比赛总结</h1><p>先说做题：</p>
<blockquote>
<p>A 题 $10 \text{ min}$ 做了，然后过了大样例，感觉没什么大问题，没有对拍（因为代码很简单，但是如果写挂了就更惨了）。</p>
</blockquote>
<blockquote>
<p>B 题花费了更多的时间，主要是想到过通项公式的，但是忘了，然后就考虑普通的转移，把部分分几乎都推完了，就差 $44$ 分，但是呢最后部分分都没有拿完，可能是公式哪里推错了。</p>
</blockquote>
<blockquote>
<p>C 题是在最后做的，考试结束之后重新看一眼暴力代码，发现排序函数都是确定的，为什么不能直接 dp 呢？回想一下，当时因为 B 和 D 都调不出来，然后心里不免有些慌乱，故根本没发现这点。</p>
</blockquote>
<blockquote>
<p>D 题是在 B 题写完部分分之后做的，当时想到了一个非常正确的解法，但是太过于冲动了，还是直接就开始写代码，调代码，后面发现可以很轻松卡掉，于是 D 题打了一个暴力就结束了，耗时 $1\text{ h}$，得分 $9$，十分不划算，还不如开 C 题。</p>
</blockquote>
<p>花费时间：$10+90+20+90$ 左右，有一些时间我也不知道在干嘛，好像是在做 B 和 D。</p>
<p>得分很难看，这里就不放了，大概是 $100+20 \sim 30+30+9$，但是我在考试之后把 B 题通项写出来之后（bdfs），发现直接二项式暴力展开就做完了，并且 C 题排序之后贪心两次也可以。</p>
<p>就算没有通项公式也能得 $100+56+100+9$ 分，为什么打这么烂呢？</p>
<blockquote>
<p>太过于冲动，自己可以留足够的时间证明代码的正确性而不是鲁莽写代码最后发现代码假了。</p>
</blockquote>
<blockquote>
<p>一些基本的数学公式会忘记，这个就只能靠我们去感性理解了，有些很出名的公式很重要。</p>
</blockquote>
<blockquote>
<p>考试过程中不能因为前面的题而影响后面的心态，按理来说 C 题剩余 $30\text{ min}$ 是能过的，但是因为 B 题如此困难以至于认为 C 题很难就打了暴力。</p>
</blockquote>
<blockquote>
<p>D 题人类智慧，我们要善于分析问题，这道题与 CSP-S 2022 T3 颇有相似性，而且随机也想到了，需要多联想一下随机的相关套路，再用之前同学讲的 $n$ 个 $0 \sim 1$ 的变量最小值的期望就能够做出来。</p>
</blockquote>
<p>教训惨重，希望 NOIP 不要翻这么离谱的车。</p>
<p>如果我们能把握好时间 + 稳定好心态 +peffect 的记忆 +Lenovo widely 就好了。</p>
<h1 id="2023-11-09-比赛总结"><a href="#2023-11-09-比赛总结" class="headerlink" title="2023-11-09 比赛总结"></a>2023-11-09 比赛总结</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/674469/something-important">here</a></p>
<h1 id="2023-11-10-比赛总结"><a href="#2023-11-10-比赛总结" class="headerlink" title="2023-11-10 比赛总结"></a>2023-11-10 比赛总结</h1><p>准备写检讨……</p>
<p>没写成</p>
<p>比赛的时候想着反正炸了就炸了，再喝一杯茶而已调整心态，然后开 T1，因为前几场都是因为简单的题没有做出来导致挂分严重，所以这次把 T1 想得很简单，大概 5 min 出来思路，就是枚举最长公共前缀，然后贪心计算即可。</p>
<p>代码写完之后没有写对拍，手搓了几组比较强的数据之后就没管了（事实上 Sub 1 的数据都是手搓的）</p>
<p>然后开 T2，把 T2 也想得比较简单，然后便开始着手构造，构造的过程中一直在尝试不同的解法，但是后面发现这些解法都可以用另一种更简单直观地方式描述（双指针贪心），这时挖掘题目的性质，然后遇到一个多余的往后面丢就可以，丢完了就没有方案，否则输出即可。</p>
<p>测了一下大样例，跟大样例的输出完全一样，也是像第一道题一样手搓了几组数据强的小样例，然后就没管了。</p>
<p>现在刚好过去 1 个小时，没想到这是我 4 个半小时比赛中的 $%90$ 的分。</p>
<p>又开始做 T3，换了一道题，感觉十分不可做，然后没有想过拿全分，但是又因为 A、B 都过了就没有太多的负担，考虑从暴力中寻找线索。</p>
<p>最后经过几个小时的艰苦奋战，发现暴力写出来跟正解应该一点关系都没有，然后打了个暴力和菊花图的性质就跑路了。</p>
<p>（后来发现不是菊花图，是菊花链，“中译中”都会出错）</p>
<p>第 4 题是在和第 3 题一起思考，然后 $n \le 5$ 的情况是很大的分类讨论，感觉当时时间要结束了，也讨论不出来，就没有写。</p>
<p>然后有一档部分分感觉很可做，但是当时思绪混乱加上第三题干扰就没有想出来，后面问了一下同学，笛卡尔树可做。</p>
<p>最后也是果然的，后两道题没人做出来，都是暴力+部分分，然后第三题看了题解是一个很抽象的做法加了一点感性理解。</p>
<p>第四题没有题解，老师也不会。。。</p>
<p>Updated on 2023-11-12 现在会了，<del>线性规划</del> 贪心+找规律。</p>
<p>大概就这样吧，希望心态能够不要有过多的波动。</p>
<h1 id="2023-11-13-比赛总结"><a href="#2023-11-13-比赛总结" class="headerlink" title="2023-11-13 比赛总结"></a>2023-11-13 比赛总结</h1><p>写检讨，先说现象，A 题挂了 $60$ 分，参加不了 NOIP 了。。。</p>
<p>原因是手造数据的时候考虑了 $2$ 操作最先的边界情况，而没有考虑 $1$ 操作最先的边界情况，而且没有对拍。</p>
<p>想的是手造的数据是很强的（事实上也造了十几组），而且过了大样例感觉没什么太大的问题，再根据前面几场比赛的经验，感觉后两道题会很难，于是铆足劲去弄后两道。</p>
<p>事实也是如此，但是实在是太难了（后两道），然后 C 题又有一定的思路就一直推，但是后面没弄出来也搞得 A 题没对拍挂掉了。</p>
<p>B 题原题，也是手造几组很强的数据，边界情况都考虑清楚了（之前做过有经验），然后就过了。</p>
<p>还是第 $1$ 个小时拿了大部分的分，后面搞后两道题，做不出来，也没有合理分配前两道题的验题时间。</p>
<p>下次我觉得可以后两道题实在想不出来了不妨看看前两道的数据，争取能够过掉大样例并且对拍，这样才是万无一失的方式。</p>
<p>下次不能再挂分了，再这样挂下去 NOIP 会考成什么样子哦。</p>
<p>一定要对拍！！！一定要顾全所有数据范围！！！一定要手搓强的数据！！！</p>
<p>最后分数比较难看，挂在了 A 题，仍然是边界情况没有考虑清楚，下次写代码的时候也得注意，检查只是辅助。</p>
<h1 id="2023-11-15-比赛总结"><a href="#2023-11-15-比赛总结" class="headerlink" title="2023-11-15 比赛总结"></a>2023-11-15 比赛总结</h1><p>前半个小时做了 T1，手搓了几组数据发现没问题跑路了。</p>
<p>然后剩下两个小时做 T2，最开始想的是分成两个 $2^8$ 跑容斥，但是发现维护不了。</p>
<p>后面又辗转想到根号分治，然后一半枚举子集，一半枚举超集就可以了，但是耽误了很多时间。</p>
<p>中途看了一下 C 题，感觉不可做去做 D 题，D 题一来想到 KMP，然后因为涉及到子树中的处理然后上线段树合并最后写一坨很烦的 $\operatorname{merge}$ 函数就可以了。</p>
<p>写了 $40 \text{ min}$ 之后测最大的样例，从第 $37500$ 行开始出错，调了 $10 \text{ min}$ 之后发现是炸 <code>long long</code> 了。</p>
<p>这个时候还剩 $1 \text{ h}$，我就做 C 题，C 题基本上能够想到思路，就是树上差分+线段树合并，最后在 $40 \text{ min}$ 中写出来过了所有样例。（样例的换行有点奇怪，建议使用手写 <code>check.cpp</code>）</p>
<p>最后对于 T1，T3，T4 造了几组小样例，过了之后给 T2 打了对拍，此时还剩 $40 \text{ min}$。</p>
<p>于是开始检查数组大小和 int &amp; long long，用各种方法测验了会不会在 Linux 下 CE，最后读题（题目中有好看的）。</p>
<p>最后没有挂分，大幸，希望明天继续如此吧。</p>
<h1 id="2023-11-16-比赛总结"><a href="#2023-11-16-比赛总结" class="headerlink" title="2023-11-16 比赛总结"></a>2023-11-16 比赛总结</h1><p>额</p>
<p>顺序开题，然后看 T1 发现可以直接 kmp 找 $next$ 数组之后随便判断一下就可以了，最后 $10 \text{ min}$ 做完。</p>
<p>接下来是 T2，T2 是一道期望，考虑到 $\dfrac{1}{r-l+1}$ 相同的放在一起做，之前做过这种类型的题，就是三个前缀和搞一下就可以了，做完的时候大概 $30 \text{ min}$。</p>
<p>然后是 T3，T3 是一道原题，<code>random_shuffle</code> 一下跑背包，之后再卡一下上下界和时间就可以了，这个时候大概 $1 \text{ h}$。</p>
<p>最后是 T4，先觉得 $O(n \sqrt{n} \log n)$ 能过，打了一个很烦的线段树和根号分治，最后是造了一组数据跑了 15s 有点害怕，发现询问复杂度是 $O(\log)$，考虑均摊一下。</p>
<p>之前做过一道题就是用分块代替树状数组均摊时间复杂度，然后这道题也是如此，于是只跑了 0.3s。</p>
<p>剩下大概 $2 \text{ h}$ 用来对拍，各种数据都上，最后写了 $4$ 个 $\text{checker}$，$8$ 个 $\text{data-maker}$，然后就过了。</p>
<p>大概就这样，没有挂分（有些阳寿成分），大幸，希望后天继续如此吧。</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\color{white}{\text{NOIP AK COS 温迪}}$</p>
<h1 id="2023-11-18-NOIP"><a href="#2023-11-18-NOIP" class="headerlink" title="2023-11-18 NOIP"></a>2023-11-18 NOIP</h1><p>。</p>
<h1 id="2023-11-28-比赛总结"><a href="#2023-11-28-比赛总结" class="headerlink" title="2023-11-28 比赛总结"></a>2023-11-28 比赛总结</h1><p>$30 \text{ min}$ 做完了。</p>
<p>A 题不是最大流的模板，所以做了很久，然后 B、C 都是最小割的模板题，所以打得比较快。</p>
<p>故开题顺序 B-&gt;C-&gt;A。</p>
<p>好消息是这次没有罚时（无论是 OI 赛制还是 ACM 赛制均是如此）</p>
<p>再接再厉。</p>
<h1 id="2023-12-02-比赛总结"><a href="#2023-12-02-比赛总结" class="headerlink" title="2023-12-02 比赛总结"></a>2023-12-02 比赛总结</h1><p>提前 $40$ 分钟离场，回去改了一下数组大小就交了。</p>
<p>A 题想了很久，感觉二分比较好，但是卡在了 $n \times m$ 是奇数的情况，于是列了一下公式，这种情况特判即可。</p>
<p>B 题很简单，用拓扑排序做一下，然后就是一个裸的最大权闭合子图了。</p>
<p>C 题没时间想了，打了一个不太对的线段树就交了。</p>
<p>后面重新回顾了一下 C 题，我们可以用 dp 求最小割，这样的话就在 $O(n^2)$ 的时间复杂度内解决了。</p>
<p>稳定发挥。</p>
<h1 id="2023-12-10-比赛总结"><a href="#2023-12-10-比赛总结" class="headerlink" title="2023-12-10 比赛总结"></a>2023-12-10 比赛总结</h1><p>首先做 T1，想到比较套路的就是一条路径拆分成三条从根到底的路径，然后离线下来统一处理就可以了，用倍增实现的大概是 $O(n \log n)$ 的时间复杂度。<del>其实可以用 Four-Russian 做到 $O(n)$。</del>这道题花了大概 $20 \text{ min}$。</p>
<p>然后是 T2，T2 比较裸，双旋转之前我们做过一道题就是形如 $\texttt{ABBA}$ 的就是双旋转字符串，于是用哈希判断一下就可以了，分析一下时间复杂度是 $O(|S| \log n)$ 的，感觉不太可过，但是写了一下代码，不管是用 <code>unordered_map</code> 还是普通的 <code>map</code> 都跑得飞快，于是就放心了。这道题花了大概 $20 \text{ min}$。</p>
<p>T3 没有想到动态开点，所以扯了很久，想到了一个类根号分治的做法，用于减少内存消耗并且有点卡常（缓存命中），于是不开 O2 过不去，开了 O2 也消耗了 700ms，做完这道大概 $1 \text{ h }30 \text{ min}$。</p>
<p>T4 昨天晚上董王说了费用流跑出来费用的单调性，再加上这道题经过分析发现是一个二分图，于是就很简单了，还好记住了 $tot$ 初始化为 $1$，大概 $2 \text{ h}$。</p>
<p>剩下两个小时用来对拍，手工造小数据和极限数据，发现都没太大问题。</p>
<p>后面没开 O2 测，跑得很慢，只不过开了 O2 就没太大问题了，跟本机测出来的结果也差不多。</p>
<p>大概就这样。</p>
<h1 id="2023-12-30-比赛总结"><a href="#2023-12-30-比赛总结" class="headerlink" title="2023-12-30 比赛总结"></a>2023-12-30 比赛总结</h1><p>T1 卡了一个半小时，导致后面两道题根本没有时间思考。</p>
<p>T1 最开始的思路是何老板的线性基和董王的线性基会不会有包含关系，如果有包含关系，那么很显然董王会输，如果没有，那么董王肯定会赢。</p>
<p>但是大样例过不了，后面也发现了这里有漏洞，也就是这并不是充要条件，而是充分条件。</p>
<p>因为有一些是何老板先选，然后董王后选，就会导致董王可以根据何老板的判断来选择，于是就把这道题搁了一会。</p>
<p>做 A 题的同时看了一下 B、C 题，B 题不太会做（到现在 12&#x2F;31 也不是很会建模），C 题猜了一个结论，就是按照之前做的异或和最大的路径来找环，一定能够找出来所有环，然而只判断了相等的边可以缩在一起，但是不相等的边没有想到用线性基减少次数，然后也挂了。</p>
<p>B 题还在思考，A 题已经有了一个想法，比赛还有 1 个小时，于是证明了一下 A 题思路的正确性，然后就过了大样例，个人感觉很对，于是就没有管了。</p>
<p>最后思考 B 题，打了 20 分的暴力跑路，因为 A 题耽误时间太多了，导致没有时间思考 100 分的做法。</p>
<p>打得很糟糕，以后一定需要合理分配题目的时间，从 CF 的比赛也能看出来，一些比较简单的结论需要想很久才能做出来，反倒是难题的思路可以一眼看出来，这种情况需要改善才行。</p>
<h1 id="2024-1-5-比赛总结"><a href="#2024-1-5-比赛总结" class="headerlink" title="2024-1-5 比赛总结"></a>2024-1-5 比赛总结</h1><p>首先，结论全部忘了。</p>
<p>A 题很显然，暴力 SG 即可，WA 了一次是因为没有把减去的东西加回去。</p>
<p>D 题很显然，对于每个石子分开考虑，然后计算 SG 即可。</p>
<p>好了，接下来就被卡住了。</p>
<p>B 题直接按照终止状态为 $(0,0)$ 来做有问题，中途也发现了 $(1,2)$ 和 $(2,1)$ 有点特殊，但是没去细想，反倒是想到了 Every-SG，但是根本没有注意到这道题并不是 Every-SG 的模板，就一直在那里写 <code>step</code> 数组，写出来发现根本不对，甚至怀疑了 Every-SG 定理的正确性，跟上次网络流 <code>tot</code> 没有初始化为 <code>1</code> 的感受一模一样。</p>
<p>一直啃 B 题，中途看了一下 F 题。</p>
<p>F 题也是秒了，但是发现我忘了台阶博弈的 SG 函数怎么计算。。。</p>
<p>只记得偶数的台阶没用。。。</p>
<p>然后蒙了一下加和乘，想过异或，但是没写，最后正解是异或。。。</p>
<p>还看了一下 C 题，C 题没打表，因为时间一直都在 B 题上面，E 题感觉是找连通块的个数？不确定呢。</p>
<p>一定要记住结论，还有就是不要混淆一些知识！</p>
<p>这场比赛需要也必须写一下题解：</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A-石子游戏"><a href="#A-石子游戏" class="headerlink" title="A-石子游戏"></a>A-石子游戏</h3><blockquote>
<p>有 $N$ 堆石头，两个玩家轮流取石子。每个人每次可以从一堆石子中取出若干个石子，每次取石子的个数有限制，谁不能取石子时就会输掉游戏。先手是否有必胜策略，如果有，第一步如何取石子。</p>
</blockquote>
<p>因为石子数量并不多，所以我们直接暴力计算当石子数量为 $i$ 的时候的 SG 值即可，时间复杂度 $O(VM)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,a[N],m,b[N],i,j,sg[N],ans,ans1,ans2;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sg[x]!=<span class="number">-1</span>) <span class="keyword">return</span> sg[x];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(x&gt;=b[i]) vis[<span class="built_in">dfs</span>(x-b[i])]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;;i++) <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> sg[x]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) ans^=sg[a[i]];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;b[i];</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>),m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sg,<span class="number">-1</span>,<span class="built_in">sizeof</span>(sg));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">dfs</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) ans^=sg[a[i]];</span><br><span class="line">	<span class="keyword">if</span>(ans)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i]&gt;=b[j])&#123;</span><br><span class="line">					a[i] -= b[j];</span><br><span class="line">					<span class="keyword">if</span>(!<span class="built_in">check</span>())&#123;</span><br><span class="line">						ans1=i,ans2=b[j];</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					a[i] += b[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans1) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-跳棋游戏"><a href="#B-跳棋游戏" class="headerlink" title="B-跳棋游戏"></a>B-跳棋游戏</h2><blockquote>
<p>有 $n$ 个棋子，第 $i$ 个棋子在 $(x_i,y_i)$，每次可以移动一颗棋子到 $(x_i-k,y_i),(x_i,y_i-k),(x_i-k,y_i-k)$ 之一（$1 \le k$），$x \ge 0,y \ge 0$，AB互相博弈，A先手，如果某人移动了某颗棋子到 $(0,0)$，此人胜利，问先手是否必胜。</p>
</blockquote>
<p>因为是移动到 $(0,0)$ 就胜利，而且有多颗棋子，我们可以考虑什么情况下面某人必败，来转化。</p>
<p>首先，一个人不会傻到移动棋子到 $(0,k),(k,0),(k,k)$，除非没有地方移动了。</p>
<p>我们就会发现如果有一个棋子位于上面三个位置，先手必胜，特判掉即可。</p>
<p>如果不，那么当且仅当棋子在 $(1,2)$ 或者 $(2,1)$ 的时候一定会移动到上面三个位置之一，这就是终止态，先手必败。</p>
<p>然后按照 SG 函数合并即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll T,n,x,y,ans,i,j,sg[N][N],temp;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>||(x==y)) <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">if</span>(sg[x][y]!=<span class="number">-1</span>) <span class="keyword">return</span> sg[x][y];</span><br><span class="line">	<span class="type">bool</span> vis[<span class="number">1005</span>];</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">		ll temp = <span class="built_in">dfs</span>(x-i,y);</span><br><span class="line">		<span class="keyword">if</span>(temp&lt;=<span class="number">1000</span>) vis[temp]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=y;i++)&#123;</span><br><span class="line">		ll temp = <span class="built_in">dfs</span>(x,y-i);</span><br><span class="line">		<span class="keyword">if</span>(temp&lt;=<span class="number">1000</span>) vis[temp]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(x,y);i++)&#123;</span><br><span class="line">		ll temp = <span class="built_in">dfs</span>(x-i,y-i);</span><br><span class="line">		<span class="keyword">if</span>(temp&lt;=<span class="number">1000</span>) vis[temp]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;;i++) <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> sg[x][y]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">memset</span>(sg,<span class="number">-1</span>,<span class="built_in">sizeof</span>(sg));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++) <span class="built_in">dfs</span>(i,j);</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		ans=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>||(x==y)) temp=<span class="number">1</span>;</span><br><span class="line">			ans^=sg[x][y];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans||temp) cout&lt;&lt;<span class="string">&quot;^o^\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;T_T\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-左空游戏"><a href="#C-左空游戏" class="headerlink" title="C-左空游戏"></a>C-左空游戏</h2><p>给定 $m,a,b,c$，然后从左往右有三堆石子数量分别为 $a,b,c$，每次可以取走 $[1,m]$ 中的石子（对于每一堆而言），但是如果某堆左边有一堆还有石子，那么这一堆的石子不可以被直接取完，谁无法执行操作就失败。</p>
<p>显然当 $a&#x3D;b&#x3D;c&#x3D;0$ 的时候先手必败，并且当 $a&#x3D;0,b&#x3D;1,c&#x3D;1$ 的时候先手必败。</p>
<p>我们考虑对于每一次操作都构造 $a&#x3D;0,b&#x3D;1,c&#x3D;1$，这个时候因为 $b$ 和 $c$ 都有石子，我们就没有不能直接取完某一堆石子的限制。</p>
<p>所以令 $b \gets b-1,c \gets c-1$，于是做一个很普通的 Nim 游戏即可，但是每一个堆都要 $\bmod \ (m+1)$。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m,a,b,c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;c,m++;</span><br><span class="line">	<span class="keyword">if</span>((a%m)^((b<span class="number">-1</span>)%m)^((c<span class="number">-1</span>)%m)) cout&lt;&lt;<span class="string">&quot;root&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;nodgd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-分裂游戏"><a href="#D-分裂游戏" class="headerlink" title="D-分裂游戏"></a>D-分裂游戏</h2><p>不想写，看 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P3185">P3185 分裂游戏 题解</a>。</p>
<h2 id="E-染色游戏"><a href="#E-染色游戏" class="headerlink" title="E-染色游戏"></a>E-染色游戏</h2><p>打表找规律，不好评价。</p>
<p>不想写，看 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P2594">P2594 染色游戏 题解</a>。</p>
<h2 id="F-棋子游戏"><a href="#F-棋子游戏" class="headerlink" title="F-棋子游戏"></a>F-棋子游戏</h2><blockquote>
<p>何老板和董王在玩一款棋子游戏，游戏虽然简单，他俩仍旧乐此不疲。游戏棋盘是一个 $n \times 20$ 的网格，棋盘上有若干个棋子。 如果一个棋子右侧为空格，则可以向右移动一格。 如果一个棋子右侧有棋子，则可以跳到右侧第一个空格。 两人轮流操作，不能操作者为输。 何老板总是先手。他想知道他是否有必胜的策略，有输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
</blockquote>
<p>显然，如果对于每个棋子我们都可以计算出它要移动多少步到最后（没有空格可以走），设移动 $i$ 步到达终点的棋子有 $cnt_i$ 个，那么每次移动，就有一部分棋子到达终点的步数减少了 $1$。</p>
<p>并且这部分棋子数量一定 $\ge 1$ 并且 $\le cnt_i$，于是就变成了一个阶梯问题。</p>
<p>第 $i$ 个台阶上有 $cnt_i$ 个棋子，每次可以从第 $i(1 \le i)$ 个台阶上选择大于等于 $1$ 个棋子移动到 $i-1$ 个台阶，无法操作者失败。</p>
<p>有一个结论，偶数台阶是没有用的，并且这个游戏的 SG 值是奇数台阶的 $cnt$ 异或和，于是多个这样的游戏的 SG 值就是这些游戏的 SG 值的异或和，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll T,n,i,j,now,a[N],m,ans,vis[N],cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			ll res = <span class="number">0</span>;</span><br><span class="line">			cin&gt;&gt;m;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;a[j],vis[a[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">20</span>,now=<span class="number">0</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(vis[j]) cnt[now]++;</span><br><span class="line">				<span class="keyword">else</span> now++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j+=<span class="number">2</span>) res^=cnt[j];</span><br><span class="line">			ans ^= res;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">20</span>;j++) vis[j]=<span class="number">0</span>,cnt[j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans) cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2024-1-6-比赛总结"><a href="#2024-1-6-比赛总结" class="headerlink" title="2024-1-6 比赛总结"></a>2024-1-6 比赛总结</h1><p>这几场比赛 A 题耗费时间太多了，基本上都是 1 个小时起步，以至于后面没时间做 D 题。</p>
<p>A 题很 CF，总是想不到那里去，Hello 2024 的 T4 很像这种类型，就是有很多个“看似正确”的做法，但是最后都挂了。</p>
<p>后面还是想到了把出现了奇数的位置删掉，然后对于剩下的元素做线性基的正确解法。</p>
<p>这种类型的题目都是很简短的题意，但是与一般的题目又不同，很类似于 NPC 让你找一个多项式复杂度的解，最后你发现它其实不是 NPC 问题。</p>
<p>这是 A 题，颇具思维。</p>
<p>然后是 B 题，B 题可能是状态压缩，但是之前没有接触过轮廓线 dp，就没有想得出来，所以转头去做网络流，首先想的是“楼上楼下”那道题目，也是环贡献为 $0$，只不过是有向图，这道题是无向图，我也在考虑用这个来做，受到二分图的影响，就想偏了。后面发现增广路可能不是偶数，于是就有一个类似于过山车那道题的解法，每条边连接两个点，每个点最多连接两条边，然后用 $\text{inf}$ 来判断是不是两端都在边界，用最大流来限制代价即可。</p>
<p>C 题是在想 B 题的时候做的，因为 C 题一个 Multi-SG 模型，所以猜个结论，肯定是每个空子树来处理即可，然后深度为 $dep$ 的空子树就是 $\operatorname{lowbit}(dep)$，这是找的规律，然后就可做了。</p>
<p>D 题根本没时间做，匆匆忙忙打了一个 $O(n^2)$ 暴力，有的地方实现有问题，换成了 $O(n^3)$ 的，最终幸好没有挂分。</p>
<p>这次我们需要发散思维解决 T1，对于 T2 不能一直想同一个解法（这次就卡在了状态压缩 dp），才能有充足的时间去做后面两道题。</p>
<h1 id="2024-1-13-比赛总结"><a href="#2024-1-13-比赛总结" class="headerlink" title="2024-1-13 比赛总结"></a>2024-1-13 比赛总结</h1><p>这次终于没有被卡在 T1 了，T1 就是一个暴力计算 SG 函数，大概花了 $20$ 分钟。（其实 T1 是 CF917B 而不是 CF459D）</p>
<p>被卡在 T2 了，感觉 T1 敲完大家都没有动静了（，于是果断放弃 T2 去做了 T4。</p>
<p>T4 比较好做，不过需要数据点分治，去掉 AC 自动机过后可以说是 DP 和矩阵乘法的模板题了，过的人也很多。</p>
<p>接下来还有 $2$ 个半小时，T3 感觉有最大值的限制，于是写了网络流，但是建图出了一些问题，一直调试，直到最后还剩 $20$ 分钟才调出来。</p>
<p>我用的是上下界网络流，当然也有直接由费用流的解法，上下界网络流的 $t \to s$ 的那条边的边权（费用）一定要谨慎设计，如果是求最大费用，最好是设计成 $-10^{18}$，如果是求最小费用，最好是设计成 $10^{18}$，主要是为了避免环的出现，反正最后跑第二遍的时候也会重复增广这条边。</p>
<p>这场比赛说明了我对网络流还是有一些不熟悉，需要多加练习，还好这次把 <code>tot</code> 初始化为 $1$ 了。</p>
<p>T2 是人类智慧，没想出来也没时间想了，网络流耽误太多时间了，这次就写到这。</p>
<h1 id="2024-1-19-比赛总结"><a href="#2024-1-19-比赛总结" class="headerlink" title="2024-1-19 比赛总结"></a>2024-1-19 比赛总结</h1><p>差点忘写了。</p>
<p>大概一个小时做完，第三题比较暴力用反素数的性质做，第四题还好没有想直接分层建图，不然可能会浪费时间。</p>
<p>后面三个小时在打对拍和卡常，三、四题常数太大了，优化了一些：</p>
<ul>
<li><p>三题增加了内存连续访问的优化。</p>
</li>
<li><p>四题去掉了二分之后继续跑费用流。</p>
</li>
</ul>
<p>然后用 Lemon 测了一下就跑得很快了，结果也和本地对拍的结果差不多。</p>
<p>大概就这样。</p>
<h1 id="2024-1-21-比赛总结"><a href="#2024-1-21-比赛总结" class="headerlink" title="2024-1-21 比赛总结"></a>2024-1-21 比赛总结</h1><p>三道题只有第一道原题会一点，后面两道题都不太会啊。</p>
<p>第一题很巧妙的构图，最后寻找欧拉回路就可以了。</p>
<p>第二题更加巧妙，可以把“堵”这个抽象的东西转化为限制，即 $tim$ 秒不能越过 $x$ 号节点，这样的话就好做多了，这启发我们要把抽象的东西要么找到性质，要么转化成具象的东西（数学公式等）。</p>
<p>第三题则是用了平面直角坐标系，可以把每次加入元素取 $\min$ 看做坐标轴上移，把减少元素取 $\max$ 看做坐标轴下移，我也觉得十分巧妙，有些想不到，多积累一下这些经验吧，该用的时候会记起来的。</p>
<p>人类智慧不只是和出题人对上脑电波，更是自身解题素养的一种体现。</p>
<h1 id="2024-1-22-比赛总结"><a href="#2024-1-22-比赛总结" class="headerlink" title="2024-1-22 比赛总结"></a>2024-1-22 比赛总结</h1><p>现在补一下。</p>
<p>省选模拟不太好做，一开始想的就是把第一道题做了，然后后面两道题尽可能骗分，但是现在看来好像结果与预期不一样。</p>
<p>第一题就做了大概两个小时，据说用点分治很快，但是我写了个答辩代码，最后还好调出来了，但是 <code>mod</code> 忘记加上去导致挂了 $60$ 分，警钟长鸣，下次遇到取模的题目一定得注意。</p>
<p>中间穿插着看了 T2 和 T3，感觉都没什么大的思路，T2 分讨，但是不太会中间的细节，也没时间写了，于是放在了一边，打了一个十分暴力的暴力。</p>
<p>T3 也不太会，也是打的暴力，但是感觉打表出来有一些规律可以寻找，想着用拉格朗日插值去试一下，但是发现不会写模板，并且我也不知道前几个元素是什么，根本插不出来。</p>
<p>最后听说 T3 输出阶乘有 $10$ 分，没拿到，大意了。</p>
<p>打得依托，只不过很多人都很依托，争取下次把能拿到的分拿全吧。</p>
<h1 id="2024-2-2-比赛总结"><a href="#2024-2-2-比赛总结" class="headerlink" title="2024-2-2 比赛总结"></a>2024-2-2 比赛总结</h1><p>首先看 A 题，看到数据范围想到数据点分治，$n \le 10$ 暴力，否则需要做一个 $\bmod \ 2$ 的背包，用 <code>bitset</code> 优化，时间复杂度觉得有点卡，然后本机测了一下发现跑得飞快就交了。</p>
<p>然后是 B 题，B 题看上去不太好做，分类讨论的情况太多，于是就想到了总数减去不合法的方案数，大概这样做，然后用差分和前缀和就做完了。但是美中不足是爆 <code>long long</code> WA 了一次，下次争取 1A。</p>
<p>看到 D 题有人过了去做 D 题，之前做过一道边权是 <code>and</code> 的题，这次边权是 <code>xor</code>，还是按套路，一层一层讨论，最后用 <code>trie</code> 树维护层中最短的边就可以了。</p>
<p>最后是 C 题，C 题是一道模板二分图博弈，采用经典结论以及 兔兔与蛋蛋的游戏 那道题的经验就可以通过了。</p>
<p>总结一下思路没什么大问题，细节还是写的时候会出一些锅，要不断优化细节，细节决定成败。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="/mus/mu3.mp3">
            </audio>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="5716fc2235b32d5b5e82"
        data-cs="907f96f6afbbcc0aca96b83eb204923010538f26"
        data-r="acoipp.github.io-"
        data-o="Acoipp"
        data-a="Acoipp"
        data-d="true"
        data-p="https://proxy-gitalk-api.netlify.app/github_access_token"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




</html>
