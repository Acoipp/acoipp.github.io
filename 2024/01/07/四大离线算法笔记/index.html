
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>四大离线算法笔记 - Acoipp 的个人博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="OI/ACM 相关笔记,四大离线算法
莫队（略）
普通莫队
带修改莫队
回滚莫队
树上莫队


线段树分治（略）
CDQ 分治（基于时间的整体二分算法）
整体二分（基于值域的整体二分算法）

CDQ 分治简单来说，即为对于,"> 
    <meta name="author" content="Acoipp"> 
    <link rel="alternative" href="atom.xml" title="Acoipp 的个人博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="四大离线算法笔记 - Acoipp 的个人博客"/>
    <meta name="twitter:description" content="OI/ACM 相关笔记,四大离线算法
莫队（略）
普通莫队
带修改莫队
回滚莫队
树上莫队


线段树分治（略）
CDQ 分治（基于时间的整体二分算法）
整体二分（基于值域的整体二分算法）

CDQ 分治简单来说，即为对于,"/>
    
    
    
    
    <meta property="og:site_name" content="Acoipp 的个人博客"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="四大离线算法笔记 - Acoipp 的个人博客"/>
    <meta property="og:description" content="OI/ACM 相关笔记,四大离线算法
莫队（略）
普通莫队
带修改莫队
回滚莫队
树上莫队


线段树分治（略）
CDQ 分治（基于时间的整体二分算法）
整体二分（基于值域的整体二分算法）

CDQ 分治简单来说，即为对于,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Acoipp 的个人博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">四大离线算法笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">四大离线算法笔记</h1>
        <div class="stuff">
            <span>一月 07, 2024</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/CDQ-%E5%88%86%E6%B2%BB/" rel="tag">CDQ 分治</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/" rel="tag">整体二分</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/" rel="tag">离线算法</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/" rel="tag">线段树分治</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E8%8E%AB%E9%98%9F/" rel="tag">莫队</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="四大离线算法"><a href="#四大离线算法" class="headerlink" title="四大离线算法"></a>四大离线算法</h1><ul>
<li>莫队（略）<ul>
<li>普通莫队</li>
<li>带修改莫队</li>
<li>回滚莫队</li>
<li>树上莫队</li>
</ul>
</li>
<li>线段树分治（略）</li>
<li>CDQ 分治（基于时间的整体二分算法）</li>
<li>整体二分（基于值域的整体二分算法）</li>
</ul>
<h1 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="CDQ 分治"></a>CDQ 分治</h1><p>简单来说，即为对于时间进行分治。</p>
<p>对于某段操作序列 $[l,r]$，分裂成 $[l,mid]$ 和 $[mid+1,r]$，分别执行分治，最后考虑 $[l,mid]$ 中的修改操作对 $[mid+1,r]$ 中的查询操作的影响。</p>
<p>对于每一个 $i$ 号，查询操作，容易证明，在它前面的修改操作都统计到了它的答案里面。</p>
<p>例 1：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4169">[Violet] 天使玩偶&#x2F;SJY摆棋子</a></p>
<p>很显然，如果暴力计算对于每个询问的贡献的话，枚举在它前面加入集合的坐标，然后计算 $|x_1-x_2|+|y_1-y_2|$ 的最小值就行了，注意到最小值是可以合并起来计算的，即不会相互影响，那么我们就可以用 CDQ 分治优化。</p>
<p>对于每个区间 $[l,r]$，先分裂，再递归，最后合并。</p>
<p>主要处理合并的问题，左边的修改可以对右边造成影响，且为了保证时间复杂度，这里的查询必须是 $O(\log)$ 级别的，这样的话整体时间复杂度才能是 $O(\log^2)$ 级别。</p>
<p>很显然，两边分别按 $x$ 排序，然后假设当前算某个询问点左下角距离它最近的点的答案，那么要求 $x_{add} \le x_{que}$ 且 $y_{add} \le y_{que}$。</p>
<p>然后用树状数组维护 $y$ 轴就可以了。</p>
<p>一共跑 $4$ 遍，但是写得好的话可以减少很多时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">	ll mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);   <span class="comment">//递归 </span></span><br><span class="line">	<span class="comment">//处理 </span></span><br><span class="line">	<span class="comment">//清空数据结构 </span></span><br><span class="line">	<span class="built_in">merge</span>(p+l,p+mid+<span class="number">1</span>,p+mid+<span class="number">1</span>,p+r+<span class="number">1</span>,temp+l,cmp);  <span class="comment">//合并（此处也可以直接排序，特别是左右部分关键字不同的情况）</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=l;i&lt;=r;i++) p[i]=temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于普通的 CDQ 分治，核心代码就这样。</p>
<p>例 2：</p>
<blockquote>
<p>给定 $n$ 个三维空间中的点，对于每个点 $i$，找到 $j$ 使得 $x_j &lt;x_i,y_j &lt; y_i,z_j&lt;z_i$ 的数量。（$1 \le n \le 10^5,1 \le x_i,y_i,z_i \le 10^9$）</p>
</blockquote>
<p>还是像上面的问题一样，将每个点看做一次询问加一次修改，注意到如果我们按点的 $x$ 轴大小顺序去加点的话是不会对答案产生影响的，因此我们先按 $x$ 从小到大排序，然后用 CDQ 分治处理 $[l,mid]$ 对 $[mid+1,r]$ 的答案。</p>
<p>很容易发现所有位于 $[l,mid]$ 的点的 $x$ 总是小于等于 $[mid+1,r]$ 的点，那么我们仍然按 $y$ 坐标合并上来，然后<strong>双指针</strong>维护 $z$ 坐标的大小关系就可以了。</p>
<p>例 3：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4093">[HEOI2016&#x2F;TJOI2016] 序列</a></p>
<p>设 $b_i$ 表示 $a_i$ 的最小可能值，$c_i$ 表示 $a_i$ 的最大可能值，那么 $i,j$ 可以连接起来当且仅当 $i&lt;j,c_i \le a_j,a_i \le b_j$。</p>
<p>这又是一个类似于上面问题的“偏序”问题，那么还是像上面一样处理答案，不过这次我们要先递归 $[l,mid]$，然后处理 $[l,mid]$ 对于 $[mid+1,r]$ 的贡献，最后递归 $[mid+1,r]$。</p>
<p>原因是因为 DP 的顺序是从小到大的，因此 CDQ 的顺序也得从小到大来计算，当然统计方案一般不存在这种问题，所以两种写法都是可以的。</p>
<p>总结一下：</p>
<ul>
<li>CDQ 用于处理左边的贡献可以合并且仅对于右边的询问产生影响的问题。</li>
<li>CDQ 也用于求解一些偏序问题。</li>
<li>CDQ 实际上是遍历一棵线段树，前序、中序和后序三种遍历方式需要视问题的不同而处理。</li>
</ul>
<p>（CDQ 分治也可以用来动态维护凸包，即优化斜率优化 DP，当然这种情况一般能被李超线段树代替，时间空间均差不了多少）</p>
<h1 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h1><p>简单来说，即为对值域进行分治求解。</p>
<p>假设我们知道了某些的询问的答案在 $[l,r]$ 内，而且可以通过 $O(\log)$ 的判定每个询问的答案在 $[l,mid]$ 还是在 $[mid+1,r]$ 内，那么可以在 $O(n \log^2 n)$ 的时间复杂度内求解每个询问。</p>
<p>一些条件：</p>
<ul>
<li>询问具有可二分性。</li>
<li>询问次数和数据的大小级别相当。</li>
</ul>
<p>时间复杂度：每个询问最多被遍历 $\log$ 次，每次需要 $O(\log)$ 的时间判定，即 $O(\log^2)$ 级别。</p>
<p>例 1：</p>
<blockquote>
<p>查询某个区间第 $k$ 小的数，没有修改，要求 $O(n \log^2 n)$ 内的时间，空间 $O(n)$。</p>
</blockquote>
<p>很明显每个询问具有可二分性，那么我们可以整体二分。</p>
<p>假设答案小于等于 $mid$，那么把 $a$ 序列中的所有小于等于 $mid$ 且大于等于 $l$ 的数都设为 $1$，那么如果询问区间内的 $1$ 的个数大于等于 $k$，那么这个询问的答案就在 $[l,mid]$ 内，否则在 $[mid+1,r]$ 内。</p>
<p>注意：如果这个询问被划到了 $[mid+1,r]$ 区间，那么 $k$ 要减去当前区间 $1$ 的个数，即去掉 $[1,mid]$ 内的数。</p>
<p>例 2：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4602">[CTSC2018] 混合果汁</a></p>
<p>判定就很简单了，用线段树上二分即可，此处不啰嗦。</p>
<p>类似于 CDQ 分治的第三道题目，我们在整体二分的时候需要先判定，然后处理在 $[l,mid]$ 里面的询问，然后清空，最后再处理 $[mid+1,r]$ 里面的询问。</p>
<p>至于为什么要这么做，因为每次判定必须用到 $[mid+1,n]$ 里面的信息，而我们不可能每次判定都循环 $mid+1 \sim n$，只能从前面的判定获取有用信息，$k$ 小值也可以用这种方法。</p>
<p>这样的话时间复杂度依然是 $O(n \log^2 n)$。</p>
<p>例 3：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF868F">Yet Another Minimization Problem</a></p>
<p>四边形不等式：</p>
<p>$$<br>w(a,c)+w(b,d) \le w(a,d)+w(b,c)<br>$$</p>
<p>我们可以简记为：交叉小于包含。</p>
<p>如果对于某个 dp 转移形如这种形式：</p>
<p>$$<br>f_r &#x3D; \max{f_l+\operatorname{value}(l,r)}<br>$$</p>
<p>如果 $\operatorname{value}$ 满足四边形不等式，那么 $f$ 函数满足决策单调性。</p>
<p>这里讲解 $f$ 函数是分阶段得到的，才能满足可用整体二分求解，否则需要用单调队列，后面再说。</p>
<p>整体二分求解很简单，$\operatorname{solve}(l,r,s,t)$ 表示 $f_l \sim f_r$ 的决策点一定位于 $s \sim t$ 中，然后每次找到 $mid &#x3D; \dfrac{l+r}{2}$ 的决策点进行递归，层数一共有 $n$ 层，每层遍历 $s \sim t$，故时间复杂度为 $n \log n$。</p>
<p>注意，每层仅可遍历 $l \sim r$ 和 $s \sim t$，不可遍历其它内容，除非时间复杂度确定，不然的话无法保证 $\log$ 级别的消耗。（类似于遍历 $l \sim t$）</p>
<p>最后转移即可。</p>
<script src="https://giscus.app/client.js"
        data-repo="acoipp/blog_pl"
        data-repo-id="R_kgDOLPCpEQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOLPCpEc4CdAa7"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="/mus/mu2.mp3">
            </audio>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="true"
        data-ci="5716fc2235b32d5b5e82"
        data-cs="907f96f6afbbcc0aca96b83eb204923010538f26"
        data-r="acoipp.github.io-"
        data-o="Acoipp"
        data-a="Acoipp"
        data-d="true"
        data-p="https://proxy-gitalk-api.netlify.app/github_access_token"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




</html>
