
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>快速沃尔什变换 FWT/子集卷积 - Acoipp 的个人博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="OI/ACM 相关笔记,快速沃尔什变换 FWT给定两个数组 $A,B$，求出 $A,B$ 经过下列变换之后得到的 $C$ 数组，快速计算。
$$C_i &amp;#x3D; \sum_{j \oplus k&amp;#x3D;i} A_j,"> 
    <meta name="author" content="Acoipp"> 
    <link rel="alternative" href="atom.xml" title="Acoipp 的个人博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="快速沃尔什变换 FWT/子集卷积 - Acoipp 的个人博客"/>
    <meta name="twitter:description" content="OI/ACM 相关笔记,快速沃尔什变换 FWT给定两个数组 $A,B$，求出 $A,B$ 经过下列变换之后得到的 $C$ 数组，快速计算。
$$C_i &amp;#x3D; \sum_{j \oplus k&amp;#x3D;i} A_j,"/>
    
    
    
    
    <meta property="og:site_name" content="Acoipp 的个人博客"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="快速沃尔什变换 FWT/子集卷积 - Acoipp 的个人博客"/>
    <meta property="og:description" content="OI/ACM 相关笔记,快速沃尔什变换 FWT给定两个数组 $A,B$，求出 $A,B$ 经过下列变换之后得到的 $C$ 数组，快速计算。
$$C_i &amp;#x3D; \sum_{j \oplus k&amp;#x3D;i} A_j,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Acoipp 的个人博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">快速沃尔什变换 FWT/子集卷积</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">快速沃尔什变换 FWT/子集卷积</h1>
        <div class="stuff">
            <span>四月 03, 2024</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/FMT/" rel="tag">FMT</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/FWT/" rel="tag">FWT</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF/" rel="tag">子集卷积</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/" rel="tag">快速沃尔什变换</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/" rel="tag">快速莫比乌斯变换</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="快速沃尔什变换-FWT"><a href="#快速沃尔什变换-FWT" class="headerlink" title="快速沃尔什变换 FWT"></a>快速沃尔什变换 FWT</h1><p>给定两个数组 $A,B$，求出 $A,B$ 经过下列变换之后得到的 $C$ 数组，快速计算。</p>
<p>$$<br>C_i &#x3D; \sum_{j \oplus k&#x3D;i} A_jB_k<br>$$</p>
<p>容易发现，快速沃尔什变换就是对下标进行卷积，当 $\oplus$ 为加法的时候就是 FFT&#x2F;NTT。</p>
<p>其中 $\oplus$ 为 $\operatorname{or},\operatorname{and},\operatorname{xor}$ 中的任意一个，它们分别被称作：或卷积，与卷积，异或卷积。</p>
<h2 id="或卷积"><a href="#或卷积" class="headerlink" title="或卷积"></a>或卷积</h2><p>求解或卷积，即为求解：</p>
<p>$$<br>C_i &#x3D; \sum_{j | k&#x3D;i} A_jB_k<br>$$</p>
<p>首先如果我们设 $A’<em>i &#x3D; \sum</em>{j \in i} A_j,B’<em>i&#x3D;\sum</em>{j \in i} B_j$，那么我们有：</p>
<p>$$<br>\begin{aligned}<br>C’i &amp;&#x3D; \sum_{j \in i} C_j \\<br>&amp;&#x3D; \sum_{k|l \in i} A_kB_l \\<br>&amp;&#x3D; \sum_{k\in i,l \in i} A_kB_l \\<br>&amp;&#x3D; \sum_{k\in i} A_k \sum_{l \in i} B_l \\<br>&amp;&#x3D; A’_i B’_i \\<br>\end{aligned}<br>$$</p>
<p>而 $A \to A’,B\to B’,C’\to C$ 都很好算，高维前缀和即可，所以时间复杂度就被优化成了 $O(n2^n)$。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gor</span><span class="params">(ll *a,ll *b,ll *c,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) fa[i]=a[i],fb[i]=b[i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++) (((fa[k+i]+=fa[k])&gt;=mod)&amp;&amp;(fa[k+i]-=mod)),(((fb[k+i]+=fb[k])&gt;=mod)&amp;&amp;(fb[k+i]-=mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//A to A&#x27;,B to B&#x27;</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=fa[i]*fb[i]%mod;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++) ((c[i+k]-=c[k])&lt;<span class="number">0</span>&amp;&amp;(c[i+k]+=mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//C&#x27; to C</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=(c[i]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与卷积"><a href="#与卷积" class="headerlink" title="与卷积"></a>与卷积</h2><p>求解与卷积，即为求解：</p>
<p>$$<br>C_i &#x3D; \sum_{j \And k&#x3D;i} A_jB_k<br>$$</p>
<p>与或卷积一样的，只不过全部 $j \in i$ 换成了 $i \in j$，公式如下：</p>
<p>首先如果我们设 $A’<em>i &#x3D; \sum</em>{i \in j} A_j,B’<em>i&#x3D;\sum</em>{i \in j} B_j$，那么我们有：</p>
<p>$$<br>\begin{aligned}<br>C’i &amp;&#x3D; \sum_{i \in j} C_j \\<br>&amp;&#x3D; \sum_{i \in (k \And l)} A_kB_l \\<br>&amp;&#x3D; \sum_{i\in k,i \in l} A_kB_l \\<br>&amp;&#x3D; \sum_{i\in k} A_k \sum_{i \in l} B_l \\<br>&amp;&#x3D; A’_i B’_i \<br>\end{aligned}<br>$$</p>
<p>求解 C 是一样的，所以就是高维后缀和，时间复杂度 $O(n2^n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gand</span><span class="params">(ll *a,ll *b,ll *c,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) fa[i]=a[i],fb[i]=b[i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++) (((fa[k]+=fa[k+i])&gt;=mod)&amp;&amp;(fa[k]-=mod)),(((fb[k]+=fb[k+i])&gt;=mod)&amp;&amp;(fb[k]-=mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=fa[i]*fb[i]%mod;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++) ((c[k]-=c[i+k])&lt;<span class="number">0</span>&amp;&amp;(c[k]+=mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=(c[i]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异或卷积"><a href="#异或卷积" class="headerlink" title="异或卷积"></a>异或卷积</h2><p>求解异或卷积，即为求解：</p>
<p>$$<br>C_i &#x3D; \sum_{j \operatorname{xor} k&#x3D;i} A_jB_k<br>$$</p>
<p>这个推导有点复杂，所以我们考虑设代码中的 $f_k&#x3D;a,f_{k+i}&#x3D;b$，那么或卷积是 $b \gets a+b$，与卷积是 $a \gets a+b$，异或卷积是 $a \gets a+b,b \gets a-b$。</p>
<p>然后最后我们要逆运算回去，异或与与和或不同，因为我们两者加起来发现多了一倍，而不是用 $a \gets a-b$ 或者 $b \gets b-a$，因此每次用 $a \gets \frac{a+b}2,b \gets \frac{a-b}{2}$ 即可。</p>
<p>具体的推导过程可以用当 $n&#x3D;2^1$ 的时候特殊情况推导，这个留作复习的时候思考吧。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gxor</span><span class="params">(ll *a,ll *b,ll *c,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) fa[i]=a[i],fb[i]=b[i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">				fa[k] += fa[k+i],fa[k+i] = fa[k]-fa[k+i]-fa[k+i];</span><br><span class="line">				fa[k] %= mod,fa[k+i] %= mod;</span><br><span class="line">				fb[k] += fb[k+i],fb[k+i] = fb[k]-fb[k+i]-fb[k+i];</span><br><span class="line">				fb[k] %= mod,fb[k+i] %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=fa[i]*fb[i]%mod;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">				c[k] += c[k+i],c[k+i] = c[k]-c[k+i]-c[k+i];</span><br><span class="line">				c[k] = c[k]*inv2%mod,c[k+i] = c[k+i]*inv2%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=(c[i]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FWT-的一些性质"><a href="#FWT-的一些性质" class="headerlink" title="FWT 的一些性质"></a>FWT 的一些性质</h2><p>上面的三个运算统称为位运算卷积，其实只有或卷积是 FWT，其他的有的叫做莫比乌斯变换等等。</p>
<p>并且由 $A \to A’$ 的过程叫做 FWT 变换，从 $A’\to A$ 的过程叫做 FWT 逆变换（IFWT），其实跟 FFT&#x2F;NTT 很像。</p>
<h3 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h3><p>我们可以发现，每次从 $A$ 数组变化到 $A’$ 数组都可以看作是一个矩阵乘法线性变换的过程，比如 $A’<em>{i}&#x3D;\sum</em>{j \in i} A_j$ 可以写作 $p_{j,i}&#x3D;[j \in i]$（转移矩阵），因此 FWT 具有结合律和分配律而不具有交换律。</p>
<p>所以如果我们在某个算法中会用到 FWT 变换的话，大部分情况都可以在程序最开始先令 $A \to A’$，然后用 $A’$ 进行变换，最后用 $A’$ 还原 $A$ 即可，但是要注意，算法里面必须进行的是线性变换才可以这么处理，例题可以参见 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5406">P5406 THUPC2019 找树</a>。</p>
<p>或者我们如果遇到了要求 $A_i &#x3D; \sum_{n_0}\sum_{n_1}\sum_{n_2}\dots\sum_{n_k}[n_0|n_1|n_2|\dots|n_k&#x3D;i]B_{n_0}B_{n_1}\dots B_{n_k}$ 这类题目的话，可以对 $B$ 直接进行 FWT 变换得到 $B’$，然后令 $A’&#x3D;B’^{k+1}$，最后通过 $A’ \to A$ 即可，这样的话时间复杂度通常会少一个 $\log$，是一个很大的优化。（证明可以通过上面的分配律或者把式子写出来展开即可） </p>
<h3 id="分位考虑"><a href="#分位考虑" class="headerlink" title="分位考虑"></a>分位考虑</h3><p>如果我们要求对于二进制下的第 $pos$ 位采用了规定的 或&#x2F;与&#x2F;异或 的运算法则，那 FWT 还适用吗？</p>
<p>答案是肯定的，我们只需要在代码的第一层枚举中记录位数，然后位数是什么就运用哪种变换就可以了，比如下面的 FWT 和 IFWT 就是这样的。</p>
<p>顺带解释一下第一层 <code>for</code> 循环是枚举高维前缀和处理的位数，第二层是枚举没有处理的位数，第三层是枚举处理过的位数，可以想象一下 $ \text{second_num}+1\text{（第一层枚举的位）}+\text{third_num} $。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">fwt</span><span class="params">(poly a)</span></span>&#123;</span><br><span class="line">	poly fa = a;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,pos=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;w);i*=<span class="number">2</span>,pos++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;w);j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[pos]==<span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">					((fa.a[k+i]+=fa.a[k])&gt;=mod)&amp;&amp;(fa.a[k+i]-=mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(s[pos]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">					((fa.a[k]+=fa.a[k+i])&gt;=mod)&amp;&amp;(fa.a[k]-=mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(s[pos]==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">					((fa.a[k]+=fa.a[k+i])&gt;=mod)&amp;&amp;(fa.a[k]-=mod),fa.a[k+i] = fa.a[k]-fa.a[k+i]*<span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;w);i++) fa.a[i]=(fa.a[i]%mod+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">ifwt</span><span class="params">(poly a)</span></span>&#123;</span><br><span class="line">	poly c = a;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,pos=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;w);i*=<span class="number">2</span>,pos++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;w);j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[pos]==<span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">					((c.a[k+i]-=c.a[k])&lt;<span class="number">0</span>)&amp;&amp;(c.a[k+i]+=mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(s[pos]==<span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">					((c.a[k]-=c.a[k+i])&lt;<span class="number">0</span>)&amp;&amp;(c.a[k]+=mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(s[pos]==<span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">					c.a[k] += c.a[k+i],c.a[k+i] = c.a[k]-c.a[k+i]*<span class="number">2</span>;</span><br><span class="line">					c.a[k] = c.a[k]*inv2,c.a[k+i] = c.a[k+i]*inv2;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;w);i++) c.a[i]=(c.a[i]%mod+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题依旧是上面那道 THUPC 的题目。</p>
<h2 id="子集卷积及其相关操作"><a href="#子集卷积及其相关操作" class="headerlink" title="子集卷积及其相关操作"></a>子集卷积及其相关操作</h2><h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h3><p>给出数组 $A,B$ 求数组 $C$，其中：<br>$$<br>C_i &#x3D; \sum_{j|k&#x3D;i,j \And k&#x3D;0} A_jB_k<br>$$<br>首先，我们可以发现如果没有 $j \And k&#x3D;0$ 这个限制就是 FWT 或卷积，但是有一个限制就是 $j \And k&#x3D;0$，考虑转化这个限制变成 $\operatorname{popcount}(j)+\operatorname{popcount}(k)&#x3D;\operatorname{popcount}(i)$，于是如果我们给 $A$ 扩展一维，给 $B$ 扩展一维，并令 $A_{i}&#x3D;A’<em>{\operatorname{popcount(i)},i}$，$B$ 同理，那么我们得到：<br>$$<br>C’</em>{\operatorname{popcount}(i),i} &#x3D; \sum_{j|k&#x3D;i} A’<em>{\operatorname{popcount(j)},j}B’</em>{\operatorname{popcount(k)},k}<br>$$<br>那么 $j$ 和 $k$ 的 $\And$ 的限制就没有了，又因为 FWT 对加法具有分配律，所以我们可以先对 $A’$ 和 $B’$ 的 $pos$ 个（$pos$ 是二进制位数）维度做 FWT 变换，然后令：<br>$$<br>C’’<em>{b,i} &#x3D; \sum</em>{b&#x3D;0}^a A’’<em>{a,i}B’’</em>{b-a,i}<br>$$<br>最后对 $C’’$ 做 IFWT 就得到了 $C’$ 的值，进而可以得到 $C$ 的值。（其实应该是枚举了一个 $b$ 就算一次累加答案，但是因为 FWT 的分配律，所以可以枚举所有 $b$ 把结果加在一起之后再 IFWT）这个时候我们发现有些值虽然它二进制下 $1$ 的个数不等于当前维度，但是它的位置上依然有值，这是正常的（这个值没用），如果这个值对后面的计算有影响，清零即可。</p>
<p>总的时间复杂度是 $O(2^nn^2)$，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gor1</span><span class="params">(ll *a,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++) (((a[k+i]+=a[k])&gt;=mod)&amp;&amp;(a[k+i]-=mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gor2</span><span class="params">(ll *a,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++) ((a[i+k]-=a[k])&lt;<span class="number">0</span>&amp;&amp;(a[i+k]+=mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) a[i]=(a[i]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">times</span><span class="params">(ll *a,ll *b,ll *c,ll n)</span></span>&#123;</span><br><span class="line">	ll limit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f0[__builtin_popcount(i)][i]=a[i],f1[__builtin_popcount(i)][i]=b[i],limit=<span class="built_in">max</span>(limit,(ll)__builtin_popcount(i));</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="built_in">gor1</span>(f0[i],n),<span class="built_in">gor1</span>(f1[i],n);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="keyword">for</span>(ll j=<span class="number">0</span>;i+j&lt;=limit;j++) <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=n;k++) f2[i+j][k]=(f2[i+j][k]+f0[i][k]*f1[j][k])%mod;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="built_in">gor2</span>(f2[i],n);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=f2[__builtin_popcount(i)][i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++) f1[i][j]=f2[i][j]=f0[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集卷积的逆运算"><a href="#子集卷积的逆运算" class="headerlink" title="子集卷积的逆运算"></a>子集卷积的逆运算</h3><p>如题，这一个小节主要探讨的是子集卷积除法的一些问题。</p>
<p>给出数组 $A,C$，求数组 $B$，这三个数组满足下面的条件：<br>$$<br>C_i &#x3D; \sum_{j|k&#x3D;i,j \And k&#x3D;0} A_jB_k<br>$$<br>根据上面子集卷积的定义，我们得到了 $A’’,B’’$ 之后，通过：<br>$$<br>C’’<em>{b,i} &#x3D; \sum</em>{b&#x3D;0}^a A’’<em>{a,i}B’’</em>{b-a,i}<br>$$<br>得到了 $C’’$，现在同理，我们得到了 $A’’,C’’$，也可以通过这个式子从 $0 \sim n$ 递推得到 $B’’$ 的值，很简单，这里有一道例题，大概就是把题目的 dp 转化为知道上面式子的 $C$ 和 $A$ 求 $B$ 的问题进而求解，时间复杂度依然是 $O(n^22^n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">div</span><span class="params">(ll *a,ll *b,ll *c,ll n)</span></span>&#123;</span><br><span class="line">	ll limit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f0[__builtin_popcount(i)][i]=a[i],f1[__builtin_popcount(i)][i]=b[i],limit=<span class="built_in">max</span>(limit,(ll)__builtin_popcount(i));</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="built_in">gor1</span>(f0[i],n),<span class="built_in">gor1</span>(f1[i],n);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		ll inv = <span class="built_in">qmi</span>(f1[<span class="number">0</span>][i],mod<span class="number">-2</span>,mod);</span><br><span class="line">		f2[<span class="number">0</span>][i]=f0[<span class="number">0</span>][i]*inv%mod;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=limit;j++)&#123;</span><br><span class="line">			f2[j][i]=f0[j][i];</span><br><span class="line">			<span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;j;k++) f2[j][i]=(f2[j][i]-f2[k][i]*f1[j-k][i]%mod+mod)%mod;</span><br><span class="line">			f2[j][i]=f2[j][i]*inv%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="built_in">gor2</span>(f2[i],n);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) c[i]=f2[__builtin_popcount(i)][i];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=limit;i++) <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++) f1[i][j]=f2[i][j]=f0[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集卷积的其他运算"><a href="#子集卷积的其他运算" class="headerlink" title="子集卷积的其他运算"></a>子集卷积的其他运算</h3><p>同理，还有开方等等其他操作，这里简单介绍一下开方，而 $\ln,\exp$ 的问题目前不需要掌握并且需要较高的数学知识因此此处不展开。</p>
<p>开方，也就是：<br>$$<br>C_i &#x3D; \sum_{j|k&#x3D;i,j \And k&#x3D;0} A_jA_k<br>$$<br>知道 $C$ 求 $A$，还是先把 $C’’$ 算出来，然后得到了：<br>$$<br>C’’<em>{b,i} &#x3D; \sum</em>{b&#x3D;0}^a A’’<em>{a,i}A’’</em>{b-a,i}<br>$$<br>然后我们从 $0$ 开始，$0$ 需要通过二次剩余求出来，然后其他项就可以递推了，也很简单，时间复杂度依然是简单的 $O(n^22^n)$，二次剩余基本不占时间。</p>
<h2 id="动态子集卷积"><a href="#动态子集卷积" class="headerlink" title="动态子集卷积"></a>动态子集卷积</h2><p>这个通常用于 dp 优化里面，也就是我们知道了 $G,Q$ 两个数组，要想通过下面的方式得到 $F$ 数组：<br>$$<br>F_S Q_S &#x3D; \sum_{T\in S,T \ne \empty} G_TF_{S&#x2F;T}<br>$$<br>$T$ 一般不可能是空集，如果强制要求 $T$ 包含某一个元素的话依然可以做。</p>
<p>首先我们发现 $\operatorname{popcount}(S&#x2F;T)&lt;\operatorname{popcount}(S)$，于是我们可以第 $i$ 次处理出所有 $F_S$ 满足 $\operatorname{popcount}(S)&#x3D;i$，因为 $G$ 和 $Q$ 是确定的，于是我们就可以通过所有 $\operatorname{popcount}(S)&lt;i$ 的 $F_S$ 得到这一层的 $F_S$，同样的，我们把 $\operatorname{popcount}$ 放到维度里面，假如我们得到了 $\operatorname{popcount}(S)&lt;i$ 的 $F_S$，我们考虑如何求出 $\operatorname{popcount}(T)&#x3D;i$ 的 $F_T$（像普通子集卷积那样给 $F$ 增加一维）：<br>$$<br>F_{\operatorname{popcount}(T),T}Q_T&#x3D;\sum_{i&#x3D;1}^{\operatorname{popcount}(T)} \sum_{j|k&#x3D;T} G_{i,j}F_{\operatorname{popcount}(T)-i,k}<br>$$<br>这样的话，求出来的答案一定是正确的，因为不合法的状态都会累加到不合法的 $F$ 上，完成整个过程之后把 $F_{i,j}(\operatorname{popcount}(j) \ne i)$ 置为 $0$ 即可。</p>
<p>容易发现，每次后面两个和式中的值都是确定的，因此我们只需要预处理出 $G$ 每一层 FWT 后的结果 $G’$ 和 $F$ 每一层 FWT 后的结果 $F’$ 即可。</p>
<p>然后就可以得到：<br>$$<br>F’<em>{\operatorname{popcount}(T),T}Q_T&#x3D;\sum</em>{i&#x3D;1}^{\operatorname{popcount}(T)} G’<em>{i,T}F’</em>{\operatorname{popcount}(T)-i,T}<br>$$<br>于是再 IFWT 回去即可，时间复杂度为 $O(n^22^n)$，例题是 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4221">P4221 WC2018 州区划分</a>，参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">nc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">char</span> buf[<span class="number">1000000</span>],*p=buf,*q=buf;</span><br><span class="line">		<span class="keyword">return</span> p==q&amp;&amp;(q=(p=buf)+<span class="built_in">fread</span>(buf,<span class="number">1</span>,<span class="number">1000000</span>,stdin),p==q)?EOF:*p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ll res = <span class="number">0</span>,w = <span class="number">1</span>;</span><br><span class="line">		<span class="type">char</span> c = <span class="built_in">nc</span>();</span><br><span class="line">		<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)w=(c==<span class="string">&#x27;-&#x27;</span>?<span class="number">-1</span>:w),c=<span class="built_in">nc</span>();</span><br><span class="line">		<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="string">&#x27;0&#x27;</span>)res=res*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">nc</span>();</span><br><span class="line">		<span class="keyword">return</span> res*w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> obuf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p34=obuf; </span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pc</span><span class="params">(<span class="type">char</span> c)</span></span>&#123; </span><br><span class="line">		p34-obuf&lt;=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)?(*p34++=c):(<span class="built_in">fwrite</span>(obuf,p34-obuf,<span class="number">1</span>,stdout),p34=obuf,*p34++=c); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(ll x)</span></span>&#123; </span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>); </span><br><span class="line">		<span class="built_in">pc</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,m,p,i,j,k,x,y,et,la[N],to[N&lt;&lt;<span class="number">5</span>],ne[N&lt;&lt;<span class="number">5</span>],w[N],du[N],fath[N],pos,f[N][<span class="number">1</span>&lt;&lt;N<span class="number">-1</span>],g[N][<span class="number">1</span>&lt;&lt;N<span class="number">-1</span>],cntt[<span class="number">1</span>&lt;&lt;N<span class="number">-1</span>],inv[<span class="number">1</span>&lt;&lt;N<span class="number">-1</span>],sum[<span class="number">1</span>&lt;&lt;N<span class="number">-1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gf</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x==fath[x]?x:fath[x]=<span class="built_in">gf</span>(fath[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qmi</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>%p,t = a;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*t%p;</span><br><span class="line">		t=<span class="number">1ll</span>*t*t%p;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fwt</span><span class="params">(ll *a,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">				(a[k+i]+=a[k])&gt;=mod&amp;&amp;(a[k+i]-=mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ifwt</span><span class="params">(ll *a,ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">				(a[k+i]-=a[k])&lt;<span class="number">0</span>&amp;&amp;(a[k+i]+=mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),p=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">		et++,ne[et]=la[x],la[x]=et,to[et]=y;</span><br><span class="line">		et++,ne[et]=la[y],la[y]=et,to[et]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) w[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">		ll cnt=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) fath[j]=j,du[j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				pos=j,cntt[i]=cntt[i-(<span class="number">1</span>&lt;&lt;j)]+<span class="number">1</span>,sum[i]=sum[i-(<span class="number">1</span>&lt;&lt;j)]+w[j+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">for</span>(k=la[j+<span class="number">1</span>];k;k=ne[k])&#123;</span><br><span class="line">					<span class="keyword">if</span>((i&gt;&gt;(to[k]<span class="number">-1</span>))&amp;<span class="number">1</span>) fath[<span class="built_in">gf</span>(j+<span class="number">1</span>)]=<span class="built_in">gf</span>(to[k]),du[j+<span class="number">1</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(du[j+<span class="number">1</span>]%<span class="number">2</span>==<span class="number">1</span>||(((i&gt;&gt;j)&amp;<span class="number">1</span>)&amp;&amp;<span class="built_in">gf</span>(pos+<span class="number">1</span>)!=<span class="built_in">gf</span>(j+<span class="number">1</span>))) cnt=<span class="number">0</span>;</span><br><span class="line">		sum[i] %= mod,inv[i] = <span class="built_in">qmi</span>(<span class="built_in">qmi</span>(sum[i],p,mod),mod<span class="number">-2</span>,mod);	</span><br><span class="line">		<span class="keyword">if</span>(!cnt) g[cntt[i]][i] = (g[cntt[i]][i]+<span class="built_in">qmi</span>(sum[i],p,mod))%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">fwt</span>(g[i],<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,<span class="built_in">fwt</span>(f[<span class="number">0</span>],<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++) <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;n);k++) f[i][k]=(f[i][k]+<span class="number">1ll</span>*g[j][k]*f[i-j][k])%mod;</span><br><span class="line">		ifwt(f[i],<span class="number">1</span>&lt;&lt;n);	</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cntt[j]==i) f[i][j]=<span class="number">1ll</span>*f[i][j]*inv[j]%mod;</span><br><span class="line">			<span class="keyword">else</span> f[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;			</span><br><span class="line">		<span class="keyword">if</span>(i&lt;n) <span class="built_in">fwt</span>(f[i],<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[n][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<script src="https://giscus.app/client.js"
        data-repo="acoipp/blog_pl"
        data-repo-id="R_kgDOLPCpEQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOLPCpEc4CdAa7"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="/mus/mu2.mp3">
            </audio>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="true"
        data-ci="5716fc2235b32d5b5e82"
        data-cs="907f96f6afbbcc0aca96b83eb204923010538f26"
        data-r="acoipp.github.io-"
        data-o="Acoipp"
        data-a="Acoipp"
        data-d="true"
        data-p="https://proxy-gitalk-api.netlify.app/github_access_token"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




</html>
